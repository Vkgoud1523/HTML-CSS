<html>
<head>
<title>World of Blockchainssss</title>
<body>


<h1><center>Consensus Algorithms: The Root Of Blockchain Technology</center></h1>


<p>Every day we see something new in blockchain technology surfacing in the midst. No matter how much we try to grasp the latest technology, they always have something new to offer to the table. Ever wonder what the root of all these blockchain technologies is? Well, consensus algorithms are the primary root of this revolutionary technology.

Consensus algorithms in blockchain are what that makes all the blockchain consensus sequences different from one another. Blockchain network facilitates millions and millions of people in the same space. So, how come they never interfere with one another or exist mutually?

The answer is in the architecture of the blockchain network. The architecture is cleverly designed, and consensus algorithms are at the core of this architecture.</p>


<h2>Table of Contents</h2>

<ol>

<li>Chapter-1: What is Consensus Algorithms?</li>

<li>Chapter-2: The Problem with Byzantine Fault Tolerance</li>

<li>Chapter-3: Why we need Consensus Algorithms?</li>

<li>Chapter-4: Blockchain: The Skeleton of Organizing Data of the Decentralized Network</li>

<li>Chapter-5: Consensus Algorithm: The Soul of the Network</li>

<li>Chapter-6: Different Types of Consensus Algorithm</li>

<li>Chapter-7: Other Types of Consensus Algorithm</li>

<li>Chapter-8: Concluding Notes</li>

</ol>


<h3><a href="">Chapter-1: What is the Consensus Algorithms?</a></h3>

<p>The technical definition would be:

Consensus algorithms are a decision-making process for a group, where individuals of the group construct and support the decision that works best for the rest of them. It’s a form of resolution where individuals need to support the majority decision, whether they liked it or not.

In simple terms, it’s just a method to decide within a group. Let me clear it up with an example. Imagine a group of ten people that want to make a decision about a project that benefits them all. Every one of them can suggest an idea, but the majority will be in favor of the one that helps them the most. Others have to deal with this decision whether they liked it or not.

Now imagine the same thing with thousands of people. Wouldn’t that drastically make it way more difficult?

Consensus algorithms do not merely agree with the majority votes, but it also agrees to one that benefits all of them. So, it’s always a win for the network.</p>

<h3>Different Types of Consensus Algorithms Infographic</h3>


<img src="https://101blockchains.com/wp-content/uploads/2018/08/Different_Consensus_Algorithms.png" width ='500'  align='right'>

<h3><a href="">Chapter-2: The Problem with Byzantine Fault Tolerance</a></h3>

<p>Byzantine Fault Tolerance is a system with a particular event of failure. It’s called the Byzantine Generals’ problem. You can best experience the situation with a distributed computer system. Many times there can be malfunctioning consensus systems.

These components are responsible for further conflicting information. Consensus systems can only work successfully if all the elements work in harmony. However, if even one of the component in this system malfunctions the whole system could break down.

Malfunctioning components always cause inconsistency in the Byzantine Fault Tolerance system, and that’s why it’s not ideal to use these consensus systems for a decentralized network.</p>

<h3><a href="">Chapter-3: Why We Need Consensus Algorithms?e</a></h3>

<p>The main problem with Byzantine is to reach an agreement. If even a single fault occurs, nodes can’t come to an agreement or have a higher difficulty value.

On the other hand, Consensus algorithms don’t really face this type of problem. Their primary target is to reach a specific goal by any means. The Blockchain consensus models are much more reliable and fault-tolerant than Byzantine.

This is why when there could be contradictory results in a distributed system; it’s best to use consensus algorithms for a better output.</p>



<h3><a href="">Chapter-4: Blockchain: The Skeleton of Organizing Data of the Decentralized Network</a></h3>


<p>Now let’s take a look inside the blockchain technology to get a better view of the whole network.

It’s a new way to organize the database.
Can store everything that changes according to the network.
All the data get arranged in a block like matter.
However, you won’t see any decentralization in the blockchain itself. This is because blockchain doesn’t provide a decentralizing environment. That’s why we need consensus algorithms to make sure the system is fully decentralized.

So, blockchain Technology would only allow you to create a different structured database, but it won’t carry out the decentralization process. This is why blockchain is considered the skeleton of the whole decentralized network.</p>




<h3><a href="">Chapter-6: Different Types of Consensus Algorithms</a></h3>

<h4>List of All Consensus Algorithms</h4>
<ol>
<li> Proof-of-Work</li> 
<li> Proof-of-Stake</li> 
<li> Delegated Proof-of-Stake</li> 
<li> Leased Proof-Of-Stake</li> 
<li> Proof of Elapsed Time</li> 
<li> Practical Byzantine Fault Tolerance</li> 
<li> Simplified Byzantine Fault Tolerance</li> 
<li> Delegated Byzantine Fault Tolerance</li> 
<li> Directed Acyclic Graphs</li> 
<li> Proof-of-Activity</li> 
<li> Proof-of-Importance</li> 
<li> Proof-of-Capacity</li> 
<li> Proof-of-Burn</li> 
<li> Proof-of-Weight</li> 

</ol>


<h3><a href="">Chapter-7: Other Types of Consensus Algorithms</a></h3>

<h4>Proof-of-Activity</h4>

<p>While people were debating the topic – Proof-of-Work vs. Proof-of-Stake, the creator of Litecoin and three other authors thought of something brilliant. They asked the world a simple question – why can’t combine the PoW and PoS instead of making them battle each other?

Thus, the idea of a fascinating hybrid came to the world – Proof-of-Activity. It combines the best two features – more secured against any attack and not a not power-hungry system.</p>

</h4>The Impacts of Proof-of-Activity</h4>


<p>One of the biggest threats a blockchain face is the 51% attack. The consensus theorem reduces the probability of the 51% attack to zero. It happens as neither the miners nor the validators can be the majority as the process would require equal contribution while adding a block to the network.

Although, some critics say that the Proof-of-Activity blockchain consensus protocol has some severe flaws. The first one will be a massive amount of energy consumption due to the mining feature. Second, Proof-of-Activity doesn’t have any solution to put a stop to the double signing of the validators. These two significant flaws kind of makes the consensus theorem a bit back footed.

Two popular blockchains adopt the Proof-of-Activity – Decred and Espers. Still, they have some variations. In reality, Decred is getting considered as the more popular one than the Espers consensus theorem.</p>

<h4>Proof-of-Importance</h4>


<p>Next on our list comes the Proof-of-Importance blockchain consensus protocol. This consensus example came to be because of the famous name of NEM. The concept is the development of the Proof-of-Stake. Although, NEM introduced a new idea – harvesting or vesting.

The harvesting mechanism determines whether a node is eligible to be added to the blockchain or not. The more you harvest on a node, the more chances it gets to be added on the chain. In return for the harvesting, the node receives the transaction fees that the validator collects as the reward. To be eligible to harvest, you need to have at least 10,000 XEM on your account.

It solves out the major problem of Proof-of-Stake. In PoS, the richer gets more money compared to the validators having less money. For example, if you own 20% of the cryptocurrency, you can mine 20% of all the blocks on the blockchain network. This makes the consensus algorithms favorable to the wealthy.</P>



<style>
h1{

font-weight:bold;
font=style: italic;
color:white;
background-color:Black;		;
}
h2{
font-style:italic;
font-size:25;
background-color:#D3D3D3;
border-bottom:3px solid black;
}

body{
 background-color:	#E0FFFF;
}

a{
 font-style:bold;
color:DarkOrange;
font-size:20;
}
li{
font-size:20;
}
p{
font-size:15;
}
h4{
font-weight:bold;

}
img{
border:2px solid white;
}
</style>
